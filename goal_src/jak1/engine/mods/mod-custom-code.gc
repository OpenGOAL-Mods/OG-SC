;;-*-Lisp-*-
(in-package goal)

;; name: mod-custom-code.gc
;; name in dgo: mod-custom-code
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
 This file contains function defenitions that are pre placed in the mod base,
    so if you place custom code inside of these functions, it will exectue based on
    the name of the function, for example, if you place (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
    to the function named runs-on-orb-pickup, then jaks powercell count will increase each time you collect
    an orb
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Begin function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun set-eps! ((entity-name string) (s entity-perm-status))
  (let ((e (entity-by-name entity-name)))
    (when e
      (logior! (-> e extra perm status) s)
      )
    )
  (none))

(defun complete-entity-if-exists ((entity-name string))
  (set-eps! entity-name (entity-perm-status complete)))

(defun kill-entity-if-exists ((entity-name string))
  (set-eps! entity-name (entity-perm-status dead)))

(define *next-unlock-str* (new 'global 'string 256 (the string #f)))
(define *next-unlock-req* -1.0)
(define *next-section-str* (new 'global 'string 256 (the string #f)))

(defun get-orb-req ((proc process-tree))
  (case (-> proc type symbol) :comp name=
    (('eco-green 'eco-blue 'eco-red 'eco-yellow) (-> (the eco proc) orb-req))
    (('ventgreen 'ventblue 'ventred 'ventyellow) (-> (the vent proc) orb-req))
    (else 0.0)
    )
  )

(deftype outrag-event (structure)
  ((orb-count int)
   (filename string)
   (filename-sdc string)
   (geyser-play? symbol)
   (sdc-time int)
   (level-orb-counts int 16) ;; expected total orb counts per level
   (conn-id int)
   )
  )

(define *outrag-sdc-unlocked?* #f)
(define *outrag-event-idx* 0)
;; (defconstant *outrag-event-max* 13) ;; moved to game-save.gc

(define *outrag-section-remaining-time* (the time-frame (seconds 780)))
(define *outrag-section-started?* #f)
(define *outrag-section-finished?* #f)
;; (define *outrag-sdc-times* (new 'global 'array 'time-frame *outrag-event-max*)) ;; moved to game-save.gc

(defconstant *unlock-count* 18)
(define *outrag-unlock-counts* (the-as (array float)
    (new 'static 'boxed-array :type float :length *unlock-count* :allocated-length *unlock-count*
      ;; 0 ;; skip dis duh
      50.0
      169.0
      358.0
      567.0
      718.0
      853.0
      1106.0
      1401.0
      1586.0
      1637.0
      1980.0
      1983.0
      1986.0
      1989.0
      1992.0
      1995.0
      2000.0
      4000.0 ;; extra to prevent endless unlock.mp3 spam
      )
    )
  )

(define *outrag-events* (the-as (array outrag-event) 
  (new 'static 'boxed-array :type outrag-event :length *outrag-event-max* :allocated-length *outrag-event-max*
    (new 'static 'outrag-event
      :orb-count 0
      :filename "outrag-0.mp3"
      :filename-sdc "outrag-0-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 0)
      :conn-id 0
      )
    (new 'static 'outrag-event
      :orb-count 50
      :filename "outrag-50.mp3"
      :filename-sdc "outrag-50-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 0)
      :conn-id 0
      )
    (new 'static 'outrag-event
      :orb-count 169
      :filename "outrag-169.mp3"
      :filename-sdc "outrag-169-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 780)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        0   ;; (village1 1)
        0   ;; (beach 2)
        0   ;; (jungle 3)
        0   ;; (misty 4)
        0   ;; (firecanyon 5)
        7   ;; (village2 6)
        0   ;; (sunken 7)
        0   ;; (swamp 8)
        0   ;; (rolling 9)
        0   ;; (ogre 10)
        16  ;; (village3 11)
        8   ;; (snow 12)
        0   ;; (cave 13)
        0   ;; (lavatube 14)
        88  ;; (citadel 15)
        )
      :conn-id 0
      )
    (new 'static 'outrag-event
      :orb-count 358
      :filename "outrag-342.mp3"
      :filename-sdc "outrag-342-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1020)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        21  ;; (village1 1)
        13  ;; (beach 2)
        0   ;; (jungle 3)
        0   ;; (misty 4)
        0   ;; (firecanyon 5)
        43  ;; (village2 6)
        0   ;; (sunken 7)
        0   ;; (swamp 8)
        6   ;; (rolling 9)
        0   ;; (ogre 10)
        20  ;; (village3 11)
        66  ;; (snow 12)
        51  ;; (cave 13)
        0   ;; (lavatube 14)
        88  ;; (citadel 15)
        )
      :conn-id 1
      )
    (new 'static 'outrag-event
      :orb-count 567
      :filename "outrag-510.mp3"
      :filename-sdc "outrag-510-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1440)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        21  ;; (village1 1)
        13  ;; (beach 2)
        0   ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        47  ;; (village2 6)
        0   ;; (sunken 7)
        69  ;; (swamp 8)
        45  ;; (rolling 9)
        0   ;; (ogre 10)
        20  ;; (village3 11)
        66  ;; (snow 12)
        51  ;; (cave 13)
        0   ;; (lavatube 14)
        88  ;; (citadel 15)
        )
      :conn-id 2
      )
    (new 'static 'outrag-event
      :orb-count 718
      :filename "outrag-639.mp3"
      :filename-sdc "outrag-639-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 960)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        21  ;; (village1 1)
        67  ;; (beach 2)
        0   ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        57  ;; (sunken 7)
        69  ;; (swamp 8)
        82  ;; (rolling 9)
        0   ;; (ogre 10)
        20  ;; (village3 11)
        66  ;; (snow 12)
        51  ;; (cave 13)
        0   ;; (lavatube 14)
        88  ;; (citadel 15)
        )
      :conn-id 3
      )
    (new 'static 'outrag-event
      :orb-count 853
      :filename "outrag-758.mp3"
      :filename-sdc "outrag-758-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1020)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        21  ;; (village1 1)
        67  ;; (beach 2)
        0   ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        57  ;; (sunken 7)
        69  ;; (swamp 8)
        82  ;; (rolling 9)
        0   ;; (ogre 10)
        20  ;; (village3 11)
        66  ;; (snow 12)
        141 ;; (cave 13)
        0   ;; (lavatube 14)
        133 ;; (citadel 15)
        )
      :conn-id 4
      )
    (new 'static 'outrag-event
      :orb-count 1106
      :filename "outrag-1041.mp3"
      :filename-sdc "outrag-1041-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1440)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        21  ;; (village1 1)
        135 ;; (beach 2)
        0   ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        111 ;; (sunken 7)
        200 ;; (swamp 8)
        82  ;; (rolling 9)
        0   ;; (ogre 10)
        20  ;; (village3 11)
        66  ;; (snow 12)
        141 ;; (cave 13)
        0   ;; (lavatube 14)
        133 ;; (citadel 15)
        )
      :conn-id 5
      )
    (new 'static 'outrag-event
      :orb-count 1401
      :filename "outrag-1336.mp3"
      :filename-sdc "outrag-1336-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 2160)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        50  ;; (village1 1)
        135 ;; (beach 2)
        99  ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        111 ;; (sunken 7)
        200 ;; (swamp 8)
        82  ;; (rolling 9)
        0   ;; (ogre 10)
        20  ;; (village3 11)
        186 ;; (snow 12)
        141 ;; (cave 13)
        0   ;; (lavatube 14)
        180 ;; (citadel 15)
        )
      :conn-id 6
      )
    (new 'static 'outrag-event
      :orb-count 1586
      :filename "outrag-1580.mp3"
      :filename-sdc "outrag-1580-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1920)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        50  ;; (village1 1)
        135 ;; (beach 2)
        99  ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        164 ;; (sunken 7)
        200 ;; (swamp 8)
        136 ;; (rolling 9)
        0   ;; (ogre 10)
        50  ;; (village3 11)
        186 ;; (snow 12)
        189 ;; (cave 13)
        0   ;; (lavatube 14)
        180 ;; (citadel 15)
        )
      :conn-id 7
      )
    (new 'static 'outrag-event
      :orb-count 1637
      :filename "outrag-1631(1).mp3"
      ;; :filename-sdc "outrag-1631(1)-SDC.mp3"
      :geyser-play? #f
      :sdc-time (seconds 0)
      :level-orb-counts (new 'static 'array int 16
        50  ;; (training 0)
        50  ;; (village1 1)
        135 ;; (beach 2)
        150 ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        164 ;; (sunken 7)
        200 ;; (swamp 8)
        136 ;; (rolling 9)
        0   ;; (ogre 10)
        50  ;; (village3 11)
        186 ;; (snow 12)
        189 ;; (cave 13)
        0   ;; (lavatube 14)
        180 ;; (citadel 15)
        )
      :conn-id 8
      )
    (new 'static 'outrag-event
      :orb-count 1637
      :filename "outrag-1631(2).mp3"
      :filename-sdc "outrag-1631(2)-SDC.mp3"
      :geyser-play? #t
      :sdc-time (seconds 600)
      :level-orb-counts (new 'static 'array int 16 
        50  ;; (training 0)
        50  ;; (village1 1)
        135 ;; (beach 2)
        150 ;; (jungle 3)
        97  ;; (misty 4)
        0   ;; (firecanyon 5)
        50  ;; (village2 6)
        164 ;; (sunken 7)
        200 ;; (swamp 8)
        136 ;; (rolling 9)
        0   ;; (ogre 10)
        50  ;; (village3 11)
        186 ;; (snow 12)
        189 ;; (cave 13)
        0   ;; (lavatube 14)
        180 ;; (citadel 15)
        )
      :conn-id 8
      )
    (new 'static 'outrag-event
      :orb-count 2000
      ;; :filename "outrag-2000.mp3" ;; special case
      :filename-sdc "outrag-2000-SDC.mp3"
      :geyser-play? #f
      :sdc-time (seconds 0) ;; special case - add up remaining time from other sections
      :level-orb-counts (new 'static 'array int 16 
        50  ;; (training 0)
        50  ;; (village1 1)
        150 ;; (beach 2)
        150 ;; (jungle 3)
        150 ;; (misty 4)
        50  ;; (firecanyon 5)
        50  ;; (village2 6)
        200 ;; (sunken 7)
        200 ;; (swamp 8)
        200 ;; (rolling 9)
        50  ;; (ogre 10)
        50  ;; (village3 11)
        200 ;; (snow 12)
        200 ;; (cave 13)
        50  ;; (lavatube 14)
        200 ;; (citadel 15)
        )
      :conn-id 9
      )
  )))

(define *outrag-conn-counts* (new 'static 'array int 10
    169
    358
    525
    676
    853
    1106
    1401
    1586
    1637
    2000
    )
  )

(define *outrag-conn-times* (new 'static 'array time-frame 10
    (seconds 780);; 169
    (seconds 1020);; 358
    (seconds 1260);; 525
    (seconds 960);; 676
    (seconds 1260);; 853
    (seconds 1440);; 1106
    (seconds 2160);; 1401
    (seconds 1920);; 1586
    (seconds 600);; 1637
    (seconds 0);; 2000
    )
  )

(defun outrag-death-reset-counter ()
  (+! (-> *game-info* total-deaths) 1)
  (when (< *outrag-event-idx* *outrag-event-max*)
    (+! (-> *game-info* deaths-per-level (-> *outrag-events* *outrag-event-idx* conn-id)) 1))
  (none)
  )

(define *ms-text* (new 'global 'string 128 (the string #f)))
(defun get-min-sec-text ((t time-frame))
  (let* ((timer-full-sec (/ t TICKS_PER_SECOND))
         (timer-min (/ timer-full-sec 60))
         (timer-sec (- timer-full-sec (* timer-min 60))))
    (if (>= timer-sec 10) ;; too lazy to figure out zero padding for floats
      (format (clear *ms-text*) "~D:~D" timer-min timer-sec)
      (format (clear *ms-text*) "~D:0~D" timer-min timer-sec)
      )
    )
  *ms-text*
  )

(define *conn-text* (new 'global 'string 128 (the string #f)))
(defun get-mod-stat-text ((want-idx int))
  (cond
    ((> want-idx (-> *outrag-events* *outrag-event-idx* conn-id))
      ;; this is a connection we haven't reached yet
      (format (clear *conn-text*) "<  ~2LCONNECTION ~D~%???? / ???? ORBS~%" (+ want-idx 1))
      )
    ((= want-idx (-> *outrag-events* *outrag-event-idx* conn-id))
      ;; this is the active connection
      (format (clear *conn-text*) "<  ~3LCONNECTION ~D~%~12L~D / ~D ORBS" (+ want-idx 1) (the int (-> *game-info* money)) (-> *outrag-conn-counts* want-idx))
      (format *conn-text* "~%~D DEATHS / RESETS" (-> *game-info* deaths-per-level want-idx))
      (when *mod-hard-mode?*
        (format *conn-text* "~%TIME REMAINING: ~S /" (get-min-sec-text *outrag-section-remaining-time*))
        (format *conn-text* " ~S" (get-min-sec-text (-> *outrag-conn-times* want-idx))))
      )
    (else
      ;; this is a completed connection
      (format (clear *conn-text*) "<  ~6LCONNECTION ~D~%~32L~D / ~D ORBS" (+ want-idx 1) (-> *outrag-conn-counts* want-idx) (-> *outrag-conn-counts* want-idx))
      (format *conn-text* "~%~D DEATHS / RESETS" (-> *game-info* deaths-per-level want-idx))
      (when *mod-hard-mode?*
        (format *conn-text* "~%TIME REMAINING: ~S /" (get-min-sec-text (-> *outrag-sdc-times* want-idx)))
        (format *conn-text* " ~S" (get-min-sec-text (-> *outrag-conn-times* want-idx))))
      )
    )

  *conn-text*
  )

(defun get-mod-stats-heading ()
  (clear *conn-text*)
  (format *conn-text* "~S ~%" 
    (if *mod-hard-mode?* "SUPER DUPER CHARGED" "SUPER CHARGED"))
  (format *conn-text* "~D DEATHS / RESETS" (-> *game-info* total-deaths))

  *conn-text*
  )


(defun jak-touch-ground? ()
 (and *target*
      (or (logtest? (-> *target* control status) (cshape-moving-flags onground onsurf on-water))
          (= (-> *target* next-state name) 'target-hit-ground)))
  )

(defun reset-sc-stuff ()
  (when (nonzero? *outrag-event-idx*)
    (format 0 "YO Resetting SC stuff~%")
    (set! *next-unlock-req* -1.0)
    (set! *outrag-event-idx* 0)
    (set! *outrag-section-remaining-time* (-> *outrag-events* 2 sdc-time))
    (set! *outrag-section-started?* #f)
    (set! *outrag-section-finished?* #f)
    )
  (none)
  )

(defun sc-reset ((cheated? symbol))
  (when (not (process-by-name 'cheat-proc *active-pool*)) ;; not already handling this
    ;; reset game loser
    (process-spawn-function process
      :name 'cheat-proc
      ;This lambda is our function
      (lambda :behavior process ((cheated? symbol))
        (when cheated?
          (let ((s (if *mod-hard-mode?* "outrag-CHEAT-SDC.mp3" "outrag-CHEAT.mp3")))
            (stop-all-sounds)
            (play-sound-file s
              (the int (-> *setting-control* default dialog-volume)))
            (suspend-for (seconds 0.1))
            ;; suspend until sound ends
            (while (is-sound-playing s)
              (suspend))
            )
          )
        (reset-sc-stuff)
        (initialize! *game-info* 'game (the-as game-save #f) "game-start")
        (set-master-mode 'game)
        (suspend-for (seconds 0.1))
        (set-blackout-frames 0)
        )
      cheated?
      )
    )
  (none)
  )

(defun player-is-playing? ()
  (if (not *target*) (return #f))
  (case (-> *target* state name) :comp name=
    (('target-title 'target-title-play 'target-title-wait) ;; nothing, plus lets stop any sounds just to be safe
      (stop-all-sounds)
      #f
      )
    (('target-continue) ;; nothing
      #f
      )
    (else
      (and (not (paused?)) (not (movie?)))
      )
    )
  )

(defun draw-section-info ()
  (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id subtitle))
    ;; special case for 2000 SC -> unlock super-duper-charged mode
    (when (and (= *outrag-event-idx* *outrag-event-max*)
               (not *mod-hard-mode?*) 
               (not *outrag-sdc-unlocked?*) 
               (>= (-> *game-info* money) 2000)
               (in-bubble-m? 3022.13 481.33 -4870.85 2.0)
               (not (process-by-name 'sc-finish-proc *active-pool*))) ;; not already running this, just to be safe
      (set! *outrag-sdc-unlocked?* #t)
      ;; autosave so we don't clear unlocked flag
      (cond
        ((< (-> *game-info* auto-save-which) 0)
          (format 0 "2000 orbs - NO AUTOSAVE DETECTED, CREATING ONE FOR SLOT 0 NOW~%")
          ;; make sure its enabled
          (set! (-> *setting-control* current auto-save) #t)
          (set! (-> *setting-control* default auto-save) #t)
          (auto-save-command 'save 0 0 *target*)
          )
        (else
          ;; (format 0 "2000 orbs - SAVING IN SLOT ~D NOW~%" (-> *game-info* auto-save-which))
          (auto-save-command 'save 0 (-> *game-info* auto-save-which) *target*)
          )
        )
      (process-spawn-function process
        :name 'sc-finish-proc
        ;This lambda is our function
        (lambda :behavior process ()
          (process-grab? *target*)
          (suspend-for (seconds 1.0)) ;; pause for a bit
          (stop-all-sounds)
          (play-sound-file "outrag-2000.mp3" (the int (-> *setting-control* default dialog-volume)))
          (suspend-for (seconds 0.1))
          ;; suspend until outrag-2000 ends
          (while (is-sound-playing "outrag-2000.mp3")
            (suspend))
          ;; reset to title screen
          (initialize! *game-info* 'game (the-as game-save #f) "title-start")
          (set-master-mode 'game)
          )
        )
      )

    (when (< *outrag-event-idx* *outrag-event-max*)
      (let* ((e (-> *outrag-events* *outrag-event-idx*)))
        (when (and (player-is-playing?)
                  (>= (-> *game-info* money) (-> e orb-count)) ;; player has met orb req
                  )
          
          ;; check if we should play voiceline and advance to next section
          (when (and (jak-touch-ground?) ;; player on the ground
                    (or (not (-> e geyser-play?)) ;; this event plays anywhere
                        (and (name= (-> (level-get-target-inside *level*) name) 'training) ;; player is in geyser...
                              ;; ...and has (at least 3/4) full blue eco (20 sec is full)
                              (send-event *target* 'query 'powerup (pickup-type eco-blue))
                              (> (- (the-as time-frame (-> *target* fact eco-timeout)) 
                                    (- (-> *display* game-frame-counter) (-> *target* fact eco-pickup-time))
                                    )
                                (seconds 15))
                              )
                        )
                    )
            ;; SDC - track playtime for this section
            ;; (when (not *outrag-section-finished?*)
              (cond
                ((zero? (-> e sdc-time))
                  ;; dont record timer for fake sections
                  )
                (else
                  ;; record this section remaining time
                  (format 0 "finishing event ~D, recording time ~D ~%" *outrag-event-idx* (/ *outrag-section-remaining-time* TICKS_PER_SECOND))
                  ;; (set! *outrag-section-finished?* #t)
                  (set! (-> *outrag-sdc-times* (-> e conn-id)) *outrag-section-remaining-time*)
                  )
                )
              ;; )
            (format 0 "playing event ~D with target state ~S~%" *outrag-event-idx* (-> *target* next-state name))
            ;; track event start/finish
            (cond
              ((zero? *outrag-event-idx*)
                ;; treat this as start of first section
                ;; (format 0 "YO zero idx set~%")
                ;; (format 0 "event 0 start dummy time!~%")
                (set! *outrag-section-remaining-time* (-> *outrag-events* 2 sdc-time))
                (set! *outrag-section-started?* #t)
                )
              ((zero? (-> e sdc-time))
                ;; do nothing for fake sections
                )
              (else
                ;; reset this for next section
                (set! *outrag-section-started?* #f)
                ;; (set! *outrag-section-finished?* #f)
                )
              )
            ;; maybe play josh voiceover
            (let ((filename (if *mod-hard-mode?* (-> e filename-sdc) (-> e filename))))
              (when (and filename (nonzero? filename))
                (process-spawn-function process
                  :name 'voice-proc
                  ;This lambda is our function
                  (lambda :behavior process ((filename string))
                    (suspend-for (seconds 1.0)) ;; pause for a bit
                    (stop-all-sounds)
                    (play-sound-file filename (the int (-> *setting-control* default dialog-volume)))
                    )
                  filename
                  )
                )
              )
            ;; advance idx
            (+! *outrag-event-idx* 1)
            (case *outrag-event-idx*
              ((0 1)
                (set! *outrag-section-remaining-time* (-> *outrag-events* 2 sdc-time))
                )
              (((- *outrag-event-max* 1))
                ;; sum up remaining times for last section
                (let ((sum 0))
                  (dotimes (i 9)
                    (+! sum (-> *outrag-sdc-times* i)))
                  ;; (format 0 "last event summed time ~D ~D~%" *outrag-event-idx* sum)
                  (set! (-> *outrag-conn-times* 9) sum)
                  (set! *outrag-section-remaining-time* sum)
                  )
                )
              ((10)
                (set! *outrag-section-remaining-time* (-> *outrag-events* 11 sdc-time))
                )
              ((11 12 13)
                ;; dont reset timer here / out of bounds
                )
              (else
                ;; (format 0 "event common time ~D~%" *outrag-event-idx*)
                (set! *outrag-section-remaining-time* (-> *outrag-events* *outrag-event-idx* sdc-time))
                )
              )
            )
          )
        )
      )
    
    (when (< *outrag-event-idx* *outrag-event-max*)
      (let* ((e (-> *outrag-events* *outrag-event-idx*)))
        ;; check if need to start section
        (when (and (player-is-playing?)
                  (not *outrag-section-started?*)
                  (not (name= (-> (level-get-target-inside *level*) name) 'training))) ;; player has left geyser
          (set! *outrag-section-started?* #t)
          ;; (format 0 "YO next section start time set~%")
          )
        ;; "tick" timer if we're not in geyser and not in blackout
        (when (not (or (name= (-> (level-get-target-inside *level*) name) 'training)
                      (level-loaded? 'intro)
                      (level-loaded? 'title)
                      (> (-> *game-info* blackout-time) (current-time))))
          (-! *outrag-section-remaining-time* (/ TICKS_PER_SECOND 60))
          )
        (when (and (player-is-playing?) (< *outrag-event-idx* *outrag-event-max*))
          (let* ((y 215))
            ;; draw section info to bottom left
            (clear *next-section-str*)
            
            ;; SDC checks
            (when (and *mod-hard-mode?* (nonzero? *outrag-event-idx*))
              ;; check if player has failed this section (SDC)
              (when (and (< *outrag-section-remaining-time* 0) ;; time is up
                        *outrag-section-started?* ;; section has started
                        (< (-> *game-info* money) (-> e orb-count)) ;; player has not met orb req (for case when headed back to geyser)
                        (not (process-by-name 'sdc-fail-proc *active-pool*))) ;; not already failing player
                ;; reset game loser
                (process-spawn-function process
                  :name 'sdc-fail-proc
                  ;This lambda is our function
                  (lambda :behavior process ()
                    ;; play fail sound
                    (stop-all-sounds)
                    (play-sound-file "outrag-fail-SDC.mp3"
                      (the int (-> *setting-control* default dialog-volume)))
                    (suspend-for (seconds 0.1))
                    ;; suspend until outrag-fail-SDC ends
                    (while (is-sound-playing "outrag-fail-SDC.mp3")
                      (suspend))
                    (reset-sc-stuff)
                    (initialize! *game-info* 'game (the-as game-save #f) "game-start")
                    (set-master-mode 'game)
                    )
                  )
                )

              ;; (when (not *outrag-section-finished?*)
                (if (> *outrag-section-remaining-time* 0)
                  (format *next-section-str* "TIME REMAINING: ~S~%" (get-min-sec-text *outrag-section-remaining-time*))
                  (format *next-section-str* "~3LTIME\c12S UP! YOU FAILED~0L~%")
                  )
                (-! y 8)
                ;; )
              )
            
            ;; show return to geyser reminder
            (when (and (>= (-> *game-info* money) (-> e orb-count)) ;; player has met orb req
                      (> *outrag-event-idx* 1)
                      (-> e geyser-play?))
              (format *next-section-str* "~3LReturn to Geyser Rock!~1L~%")
              (-! y 8)
              )
            (case *outrag-event-idx*
              ((0 1)
                (format *next-section-str* "Connection ~D Goal: ~D Orbs" 1 169))
              ;; ((11 12)
              ;;   (format *next-section-str* "Connection ~D Goal: ~D Orbs" (- *outrag-event-idx* 2) (-> e orb-count)))
              (else
                (format *next-section-str* "Connection ~D Goal: ~D Orbs" (+ (-> e conn-id) 1) (-> e orb-count)))
              )
            (draw-string-xy *next-section-str* buf 4 y (font-color white) (font-flags shadow kerning))
            )
          )
        )
      )
    )
  (none)
  )

(defun draw-unlock-info ()
  (when (player-is-playing?)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id subtitle))
      ;; play unlock sound effect if we just met the req from last frame, and we're not fresh outta blackout (loading save)
      (when (and (> *next-unlock-req* 0.0) (<= *next-unlock-req* (-> *game-info* money))
                (> (current-time) (+ (-> *game-info* blackout-time) (seconds 3))))
        (play-sound-file "unlock.mp3" (the int (-> *setting-control* default sfx-volume)))
        )
      
      ;; find next unlock amount
      (let ((tmp-unlock-req -1.0))
        (dotimes (i *unlock-count*)
          (let ((req (-> *outrag-unlock-counts* i)))
            (when (and (> req (-> *game-info* money))
                      (or (< tmp-unlock-req 0)
                          (< req tmp-unlock-req)))
                (set! tmp-unlock-req req)
              )
            )
          )
        ;; only increase, to prevent
        (when (> tmp-unlock-req *next-unlock-req*)
          (set! *next-unlock-req* tmp-unlock-req)
          )
        )

      (cond 
        ((and (>= *next-unlock-req* 0) (<= *next-unlock-req* 2000))
          ;; (let* ((p (ppointer->process *next-unlock-ptr*)))
            (format (clear *next-unlock-str*) "Next Unlock in ")
            ;; (format *next-unlock-str* (case (-> p type symbol)
            ;;     (('eco-green)   "~6LGreen Eco Cluster~1L~%")
            ;;     (('eco-blue)    "~7LBlue Eco Cluster~1L~%")
            ;;     (('eco-red)     "~3LRed Eco Cluster~1L~%")
            ;;     (('eco-yellow)  "~5LYellow Eco Cluster~1L~%")
            ;;     (('ventgreen)   "~6LGreen Eco Vent~1L~%")
            ;;     (('ventblue)    "~7LBlue Eco Vent~1L~%")
            ;;     (('ventred)     "~3LRed Eco Vent~1L~%")
            ;;     (('ventyellow)  "~5LYellow Eco Vent~1L~%")
            ;;     )
            ;;   )
            (format *next-unlock-str* "~D Orb~S (~D/~D)"
              (the int (- *next-unlock-req* (-> *game-info* money)))
              (if (> (- *next-unlock-req* (-> *game-info* money)) 1) "s" "") ;; optional s :)
              (the int (-> *game-info* money))
              (the int *next-unlock-req*)
              )
            ;; )
          (draw-string-xy *next-unlock-str* buf 508 215 (font-color white) (font-flags right shadow kerning))
          )
        (else
          (format (clear *next-unlock-str*) "Next Unlock ~2LN/A")
          (draw-string-xy *next-unlock-str* buf 508 215 (font-color white) (font-flags right shadow kerning))
          )
        )   
      )
    )
    (none)
  )

(defun play-missing-orb-hint ()
  (cond
    (*mod-hard-mode?*
      ;; no hint for u
      (play-sound-file "outrag-HINT-SDC.mp3" (the int (-> *setting-control* default dialog-volume)))
      )
    (else
      (let ((missing-lvl-idx -1)
            (e (-> *outrag-events* *outrag-event-idx*)))
        (dotimes (idx 16)
          (when (< (-> *game-info* money-per-level idx) (-> e level-orb-counts idx))
            (if (< missing-lvl-idx 0)
              (set! missing-lvl-idx idx)  ;; first level missing orbs
              (set! missing-lvl-idx 1000) ;; more than one level missing orbs
              )
            )
          )
        (case missing-lvl-idx
          ((0) (play-sound-file     "outrag-HINT-GR.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((1) (play-sound-file     "outrag-HINT-SV.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((2) (play-sound-file     "outrag-HINT-SB.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((3) (play-sound-file     "outrag-HINT-FJ.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((4) (play-sound-file     "outrag-HINT-MI.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((5) (play-sound-file     "outrag-HINT-FC.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((6) (play-sound-file     "outrag-HINT-RV.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((7) (play-sound-file     "outrag-HINT-LPC.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((8) (play-sound-file     "outrag-HINT-BS.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((9) (play-sound-file     "outrag-HINT-PB.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((10) (play-sound-file    "outrag-HINT-MP.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((11) (play-sound-file    "outrag-HINT-VC.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((12) (play-sound-file    "outrag-HINT-SM.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((13) (play-sound-file    "outrag-HINT-SC.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((14) (play-sound-file    "outrag-HINT-LT.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((15) (play-sound-file    "outrag-HINT-GMC.mp3" (the int (-> *setting-control* default dialog-volume))))
          ((1000) (play-sound-file  "outrag-HINT-2Levels.mp3" (the int (-> *setting-control* default dialog-volume))))
          )
        )
      )
    )

  (none)
  )

(defun runs-every-frame ()
  ;; play hints off (why do they keep turning on?)
  (false! (-> *setting-control* default play-hints))

  ;; toggle hud-collectable-view
  (when (and (cpad-hold? 0 l2) (cpad-pressed? 0 left))
    (+! *hud-collectable-view* 1)
    (when (> *hud-collectable-view* (hud-collectable-view level-totals))
      (set! *hud-collectable-view* (hud-collectable-view original)))
    )

  ;; set mood and time of day
  (let ((lvl (level-get-target-inside *level*)))
    ;; twilight time of day in geyser
    (when (name= (-> lvl name) 'training)
      (set! (-> *time-of-day-proc* 0 time-ratio) 0.0) (set! (-> *time-of-day-proc* 0 hour) 19)
      )
    ;; set/reset mood
    (cond
      ((and *mod-hard-mode?* *mod-lightning?*
            (case (-> lvl name) :comp name=
              (('jungleb 'maincave 'robocave 'darkcave 'lavatube 'citadel 'finalboss) #f) ;; no lightning effect
              (else #t)
              )
            )
        ;; lightning
        ;; (set! (-> lvl mood) *sdc-mood*)
        (set! (-> lvl mood-func) update-mood-sdc)
        )
      (else
        ;; restore original mood from level-load-info
        (set! (-> lvl mood) (the mood-context (-> lvl info mood value)))
        (set! (-> lvl mood-func) (the (function mood-context float int none) (-> lvl info mood-func value)))
        )
      )
    )

  ;; close most tasks
  (dotimes (i (game-task max))
    (case i
      (((game-task none) (game-task complete) ;; dont care
        (game-task leaving-misty) ;; dont care
        (game-task assistant-village3) ;; unused
        ;; (game-task jungle-eggtop) ;; keep this open (blue eco switch)
        )
        ;; do nothing, don't close these tasks
        )
      (((game-task finalboss-movies))
        ;; close unless we're in superdupercharged mode
        ;; (when (and (not *mod-hard-mode?*)
        ;;            (not (task-closed? (the-as game-task i) (task-status need-reward-speech))))
        ;;   (close-specific-task! (the-as game-task i) (task-status need-reward-speech))
        ;;   )
        )
      (((game-task plunger-lurker-hit))
        (when (not (task-closed? (the-as game-task i) (task-status need-hint)))
          (close-specific-task! (the-as game-task i) (task-status need-hint))
          )
        )
      (((game-task village3-button))
        (when (not (task-closed? (the-as game-task i) (task-status need-introduction)))
          (close-specific-task! (the-as game-task i) (task-status need-introduction))
          )
        )
      (((game-task firecanyon-assistant) (game-task village2-levitator) (game-task lavatube-start) (game-task village4-button)) 
        (when (not (task-closed? (the-as game-task i) (task-status need-reward-speech)))
          (close-specific-task! (the-as game-task i) (task-status need-reward-speech))
          )
        )
      (else
        (when (not (task-closed? (the-as game-task i) (task-status need-resolution)))
          (logior! (-> *game-info* task-perm-list data i status) (entity-perm-status real-complete))
          (close-specific-task! (the-as game-task i) (task-status need-resolution))
          )
        )
      )
    )

  ;; keep level names from popping up
  (mark-text-as-seen *game-info* (text-id training-level-name))
  (mark-text-as-seen *game-info* (text-id village1-level-name))
  (mark-text-as-seen *game-info* (text-id beach-level-name))
  (mark-text-as-seen *game-info* (text-id jungle-level-name))
  (mark-text-as-seen *game-info* (text-id misty-level-name))
  (mark-text-as-seen *game-info* (text-id firecanyon-level-name))
  (mark-text-as-seen *game-info* (text-id village2-level-name))
  (mark-text-as-seen *game-info* (text-id sunken-level-name))
  (mark-text-as-seen *game-info* (text-id swamp-level-name))
  (mark-text-as-seen *game-info* (text-id rolling-level-name))
  (mark-text-as-seen *game-info* (text-id ogre-level-name))
  (mark-text-as-seen *game-info* (text-id village3-level-name))
  (mark-text-as-seen *game-info* (text-id snow-level-name))
  (mark-text-as-seen *game-info* (text-id cave-level-name))
  (mark-text-as-seen *game-info* (text-id lavatube-level-name))
  (mark-text-as-seen *game-info* (text-id citadel-level-name))

  ;; kill some entities that don't respect their task status
  ;; sandover
  (complete-entity-if-exists "yakow-8")
  (complete-entity-if-exists "yakow-9")
  (complete-entity-if-exists "yakow-10")
  (complete-entity-if-exists "yakow-11")
  (complete-entity-if-exists "yakow-12")
  ;; beach
  (complete-entity-if-exists "ecoventrock-7")
  (complete-entity-if-exists "ecoventrock-4")
  (complete-entity-if-exists "ecoventrock-5")
  (complete-entity-if-exists "ecoventrock-3")
  (complete-entity-if-exists "ecoventrock-6")
  (kill-entity-if-exists "seagullflock-1")
  ;; jungle
  (complete-entity-if-exists "reflector-mirror-2")
  (complete-entity-if-exists "periscope-11")
  (complete-entity-if-exists "periscope-12")
  (complete-entity-if-exists "periscope-13")
  (complete-entity-if-exists "periscope-14")
  (complete-entity-if-exists "periscope-15")
  ;; jungleb
  (complete-entity-if-exists "plant-boss-3")
  ;; misty
  (kill-entity-if-exists "misty-battlecontroller-1")
  ;; (let ((bc (entity-by-name "misty-battlecontroller-1")))
  ;;   (when bc (set! (-> bc extra perm user-int8 0) 1)))
  (complete-entity-if-exists "silostep-7")
  (complete-entity-if-exists "silostep-8")
  (complete-entity-if-exists "silostep-9")
  (complete-entity-if-exists "silostep-10")
  ;; rolling
  (complete-entity-if-exists "lightning-mole-2")
  (complete-entity-if-exists "lightning-mole-3")
  (complete-entity-if-exists "lightning-mole-4")
  (complete-entity-if-exists "lightning-mole-5")
  (complete-entity-if-exists "robber-2")
  (complete-entity-if-exists "robber-3")
  (complete-entity-if-exists "robber-4")
  (complete-entity-if-exists "robber-5")
  ;; ogre
  (complete-entity-if-exists "ogreboss-1")
  ;; maincave
  (complete-entity-if-exists "gnawer-14")
  (complete-entity-if-exists "gnawer-19")
  (complete-entity-if-exists "gnawer-18")
  (complete-entity-if-exists "gnawer-17")
  (complete-entity-if-exists "gnawer-15")
  (complete-entity-if-exists "gnawer-13")
  (complete-entity-if-exists "gnawer-12")
  (complete-entity-if-exists "gnawer-16")
  (complete-entity-if-exists "gnawer-11")
  (complete-entity-if-exists "dark-crystal-1")
  (complete-entity-if-exists "dark-crystal-3")
  (complete-entity-if-exists "dark-crystal-4")
  (complete-entity-if-exists "dark-crystal-5")
  ;; darkcave
  (complete-entity-if-exists "dark-crystal-2")
  ;; snowy
  (complete-entity-if-exists "snow-bumper-72")
  (complete-entity-if-exists "snow-bumper-73")
  (complete-entity-if-exists "snow-bumper-81")
  (complete-entity-if-exists "snow-bumper-79")
  (complete-entity-if-exists "snow-bumper-78")
  (complete-entity-if-exists "snow-bumper-70")
  (complete-entity-if-exists "snow-bumper-71")
  (complete-entity-if-exists "snow-bumper-69")
  (complete-entity-if-exists "snow-bumper-80")
  (complete-entity-if-exists "snow-bumper-74")
  (complete-entity-if-exists "snow-bumper-75")
  (complete-entity-if-exists "snow-bumper-77")
  (complete-entity-if-exists "snow-bumper-76")
  (complete-entity-if-exists "ram-15")
  (complete-entity-if-exists "ram-8")
  (complete-entity-if-exists "ram-7")
  (complete-entity-if-exists "ram-14")
  (complete-entity-if-exists "ram-13")
  (kill-entity-if-exists "crate-2986")
  ;; citadel
  (complete-entity-if-exists "citb-generator-1")
  (complete-entity-if-exists "citb-generator-2")
  (complete-entity-if-exists "citb-generator-3")
  (complete-entity-if-exists "citb-generator-4")
  (let ((bc (entity-by-name "citb-battlecontroller-1")))
    (when bc (set! (-> bc extra perm user-int8 0) 1)))
  (complete-entity-if-exists "citb-generator-5")
  (complete-entity-if-exists "citb-generator-6")
  (complete-entity-if-exists "citb-generator-7")
  ;; finalboss
  (when (not *mod-hard-mode?*)
    (kill-entity-if-exists "robotboss-3"))

  ;; (maybe) draw the info about section, next unlockable
  (draw-section-info)
  (draw-unlock-info)

  ;; check if player should be dead but isn't
  (when (and *target* 
             (!= (-> *target* state name) 'target-grab)
             (not (logtest? (-> *target* state-flags) (state-flags being-attacked dying)))
             (<= (-> *target* fact health) 0.0))
    ;; (format 0 "killing player backup~%")
    (send-event *target* 'attack-invinc #f (static-attack-info ((mode 'generic))))
    )

  ;; check if player is near geyser vent and wants a hint
  (when (and *target* (or (in-bubble-m? -1311.39   6.77 1056.64  5.0) (in-bubble-m? -1418.61   3.81 1010.54  5.0))
             (not (logtest? (-> *target* state-flags) (state-flags being-attacked dying)))
             (>= *outrag-event-idx* 2) ;; only after geyser sections
             (not (is-sound-playing "")) ;; wait for any sounds to finish
             (not (paused?))
             (not (process-by-name 'voice-proc *active-pool*)) ;; voice line isnt pending/playing
             )
    ;; try to show prompt
    (kill-current-level-hint '() '(sidekick voicebox ambient) 'exit)
    (level-hint-surpress!)
    (let ((gp-1 (new 'stack 'font-context *font-default-matrix* 32 140 0.0 (font-color default) (font-flags shadow kerning))))
      (let ((v1-57 gp-1)) (set! (-> v1-57 width) (the float 440)))
      (let ((v1-58 gp-1)) (set! (-> v1-58 height) (the float 60)))
      (let ((v1-59 gp-1)) (set! (-> v1-59 scale) 0.9))
      (set! (-> gp-1 flags) (font-flags shadow kerning middle-vert large))
      (print-game-text (lookup-text! *common-text* (text-id press-for-hint) #f) gp-1 #f 128 22))
    ;; hint requested
    (when (cpad-pressed? 0 circle)
      (play-missing-orb-hint)
      )
    )

  (if *show-input-display* (input-display-on) (input-display-off))
  ;; ensure orb-placer is spawned/killed as requested, debug menu is updated
  ;; (when *debug-segment*
    (orb-placer-maintenance);;)
  (none))

(defun runs-on-orb-pickup ((parent process-tree))
  (let* ((from-cache? (and parent (type-type? (-> parent type) orb-cache-top))))
    ;; Code here runs on ANY orb pickup
    (when from-cache?
      ;; Code here runs only if the orb was from an orb cache
      )
    (when (not from-cache?)
      ;; Code here runs only if the orb was NOT from an orb cache
      ))
  (none))

(defun runs-on-fly-pickup ()
  ;; Code here runs on any scout fly pickup
  (none))

(defun runs-on-cell-pickup ((cell-event symbol))
  (case cell-event
    (('pickup)
     ;; Code here runs as soon as you pickup a powercell
     )
    (('cutscene-end)
     ;; Code here runs at the end of any powercell cutscene
     ))
  (none))

(defun runs-on-eco-pickup ((eco-type pickup-type) (parent process-tree))
  (let* ((from-vent? (and parent (type-type? (-> parent type) vent))))
    ;; Code here runs as soon as you pickup ANY eco
    (case eco-type
      (((pickup-type eco-yellow))
       ;; Code here runs as soon as you pickup yellow eco
       )
      (((pickup-type eco-red))
       ;; Code here runs as soon as you pickup red eco
       )
      (((pickup-type eco-blue))
       ;; Code here runs as soon as you pickup blue eco
       )
      (((pickup-type eco-pill))
       ;; Code here runs as soon as you pickup small green eco
       )
      (((pickup-type eco-green))
       ;; Code here runs as soon as you pickup big green eco 
       ))
    (when from-vent?
      ;; Code here runs only if the eco was picked up from a vent
      ))
  (none))

(defun runs-on-jak-spawn ()
  ;; Code here runs every time jak spawns (loading a file new game or death)
  ;;uncomment this to use custom music for custom levels - the function is in mod-common-functions.gc
  ;;(process-spawn-function process music-manager-proc)
  
  ;; fix some pause shit
  (remove-setting *setting-control* *target* 'allow-pause)
  (remove-setting *setting-control* *target* 'allow-progress)
  (apply-settings *setting-control*)
  
  ;; full HP and blue eco
  (send-event *target* 'get-pickup (pickup-type eco-blue) (-> *FACT-bank* eco-full-inc)) ;; mod change - full blue eco on spawn
  (set! (-> *target* fact health) 3.0)
  (set! (-> *target* fact eco-pill) 50.0) ;; 4HP

  ;; make sure we have an autosave, defaulting to slot 0
  (when (and (not *debug-segment*) (< (-> *game-info* auto-save-which) 0))
    (format 0 "TARGET SPAWN - NO AUTOSAVE DETECTED, CREATING ONE FOR SLOT 0 NOW~%")
    ;; make sure its enabled
    (set! (-> *setting-control* current auto-save) #t)
    (set! (-> *setting-control* default auto-save) #t)
    (auto-save-command 'save 0 0 *default-pool*)
    )

  (none))

(defun runs-on-jak-death ((death-event symbol))
  (case death-event
    (('dying)
     ;; Code here runs immediately every time jak dies, before any death animation or death cutscene
     )
    (('blackout)
     ;; Code here runs after jak dies (and any death cutscene finishes), during the blackout before he spawns
     ))
  (none))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; deprecated function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| these are no longer recommended/supported however we include them anyways to not break anyones mods. |#
