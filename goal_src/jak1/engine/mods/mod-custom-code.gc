;;-*-Lisp-*-
(in-package goal)

;; name: mod-custom-code.gc
;; name in dgo: mod-custom-code
;; dgos: TODO

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; What is this file for.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#|
 This file contains function defenitions that are pre placed in the mod base,
    so if you place custom code inside of these functions, it will exectue based on
    the name of the function, for example, if you place (set! (-> *game-info* fuel) (+ (-> *game-info* fuel) 1))
    to the function named runs-on-orb-pickup, then jaks powercell count will increase each time you collect
    an orb
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Begin function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun set-eps! ((entity-name string) (s entity-perm-status))
  (let ((e (entity-by-name entity-name)))
    (when e
      (logior! (-> e extra perm status) s)
      )
    )
  (none))

(defun complete-entity-if-exists ((entity-name string))
  (set-eps! entity-name (entity-perm-status complete)))

(defun kill-entity-if-exists ((entity-name string))
  (set-eps! entity-name (entity-perm-status dead)))

(define *next-unlock-str* (new 'global 'string 256 (the string #f)))
(define *next-section-str* (new 'global 'string 256 (the string #f)))
(define *next-unlock-req* 0.0)
(define *next-unlock-ptr* (the-as (pointer process) #f))

(defun get-orb-req ((proc process-tree))
  (case (-> proc type symbol) :comp name=
    (('eco-green 'eco-blue 'eco-red 'eco-yellow) (-> (the eco proc) orb-req))
    (('ventgreen 'ventblue 'ventred 'ventyellow) (-> (the vent proc) orb-req))
    (else 0.0)
    )
  )

(deftype outrag-event (structure)
  ((orb-count int)
   (filename string)
   (geyser-play? symbol)
   (sdc-time int))
  )

(define *outrag-sdc-unlocked?* #f)
(define *outrag-event-idx* 0)
(defconstant *outrag-event-max* 12)

(define *outrag-section-start-time* (the time-frame #f))
(define *outrag-section-started?* #f)
(define *outrag-section-finished?* #f)
(define *outrag-sdc-times* (new 'global 'array 'time-frame *outrag-event-max*))

(define *outrag-events* (the-as (array outrag-event) 
  (new 'static 'boxed-array :type outrag-event :length *outrag-event-max* :allocated-length *outrag-event-max*
    (new 'static 'outrag-event
      :orb-count 0
      :filename "outrag-0.mp3"
      :geyser-play? #f
      :sdc-time (seconds 0)
      )
    (new 'static 'outrag-event
      :orb-count 50
      :filename "outrag-50.mp3"
      :geyser-play? #f
      :sdc-time (seconds 0)
      )
    (new 'static 'outrag-event
      :orb-count 169
      :filename "outrag-169.mp3"
      :geyser-play? #t
      :sdc-time (seconds 20)
      )
    (new 'static 'outrag-event
      :orb-count 342
      :filename "outrag-342.mp3"
      :geyser-play? #t
      :sdc-time (seconds 960)
      )
    (new 'static 'outrag-event
      :orb-count 510
      :filename "outrag-510.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1260)
      )
    (new 'static 'outrag-event
      :orb-count 639
      :filename "outrag-639.mp3"
      :geyser-play? #t
      :sdc-time (seconds 840)
      )
    (new 'static 'outrag-event
      :orb-count 758
      :filename "outrag-758.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1080)
      )
    (new 'static 'outrag-event
      :orb-count 1041
      :filename "outrag-1041.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1440)
      )
    (new 'static 'outrag-event
      :orb-count 1336
      :filename "outrag-1336.mp3"
      :geyser-play? #t
      :sdc-time (seconds 2160)
      )
    (new 'static 'outrag-event
      :orb-count 1580
      :filename "outrag-1580.mp3"
      :geyser-play? #t
      :sdc-time (seconds 1920)
      )
    (new 'static 'outrag-event
      :orb-count 1631
      :filename "outrag-1631.mp3"
      :geyser-play? #f
      :sdc-time (seconds 600)
      )
    (new 'static 'outrag-event
      :orb-count 2000
      :filename "outrag-2000.mp3"
      :geyser-play? #f
      :sdc-time (seconds 0)
      )
  )))

(defun jak-touch-ground? ()
 (and *target*
      (or (logtest? (-> *target* control status) (cshape-moving-flags onground onsurf on-water))
          (= (-> *target* next-state name) 'target-hit-ground)))
  )

(defun reset-sc-stuff ()
  (when (nonzero? *outrag-event-idx*)
    (format 0 "Resetting SC stuff~%")
    (set! *next-unlock-req* 0.0)
    (set! *outrag-event-idx* 0)
    (set! *outrag-section-start-time* (real-current-time))
    (set! *outrag-section-started?* #f)
    (set! *outrag-section-finished?* #f)
    (dotimes (i *outrag-event-max*)
      ;; reset all section times to 0 - I guess we don't really need this? idk why its crashing tho
      ;; (set! (-> *outrag-sdc-times* i) 0)
      )
    )
  (none)
  )

(defun draw-section-info ()
  (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id subtitle))
    ;; if 2000 orbs collected, unlock super-duper-charged mode
    (when (and (not *outrag-sdc-unlocked?*) (>= (-> *game-info* money) 2000))
      (set! *outrag-sdc-unlocked?* #t)
      (play-sound-file "outrag-sdc.mp3" (the int (-> *setting-control* default dialog-volume)))
      )

    (let* ((e (-> *outrag-events* *outrag-event-idx*)))
      (when (and (< *outrag-event-idx* (- *outrag-event-max* 1))
                 (>= (-> *game-info* money) (-> e orb-count)) ;; player has met orb req
                 )
        ;; SDC - track playtime for this section if we just met orb goal
        (when (and *mod-hard-mode?* (not *outrag-section-finished?*))
          (case *outrag-event-idx*
            ((0 1)
              ;; dont record timer for fake sections
              )
            (else
              ;; record this section remaining time
              (format 0 "finishing event ~D ~%" *outrag-event-idx*)
              (set! *outrag-section-finished?* #t)
              (set! (-> *outrag-sdc-times* *outrag-event-idx*) (- (real-current-time) *outrag-section-start-time*))
              )
            )
          )
        ;; check if we should play voiceline and advance to next section
        (when (and (jak-touch-ground?) ;; player on the ground
                   (or (not (-> e geyser-play?)) ;; this event plays anywhere
                       (name= (-> (level-get-target-inside *level*) name) 'training)) ;; player is in geyser
                   )
          (format 0 "triggering event ~D with target state ~S~%" *outrag-event-idx* (-> *target* next-state name))
          ;; SDC - track playtime for this section
          (when *mod-hard-mode?*
            (case *outrag-event-idx*
              ((0)
                ;; dont record timer for first section
                (set! *outrag-section-start-time* (real-current-time))
                (set! *outrag-section-started?* #t)
                )
              ((1)
                ;; dont reset started for fake sections
                )
              (else
                ;; reset this for next section
                (set! *outrag-section-started?* #f)
                (set! *outrag-section-finished?* #f)
                )
              )
            )
          ;; play josh voiceover
          (play-sound-file (-> e filename) 
            (the int (-> *setting-control* default dialog-volume)))
          ;; advance idx
          (+! *outrag-event-idx* 1)
          )
        )
      )

    (let* ((e (-> *outrag-events* *outrag-event-idx*)))
      ;; check if need to start section
      (when (and (not *outrag-section-started?*)
                 (not (name= (-> (level-get-target-inside *level*) name) 'training))) ;; player has left geyser
        (set! *outrag-section-started?* #t)
        (set! *outrag-section-start-time* (real-current-time))
        )
      
      (let* ((y 215)
            (section-time (case *outrag-event-idx*
                ((0 1) (-> *outrag-events* 2 sdc-time))
                ((11) 
                  ;; sum up remaining times
                  (let ((sum 0))
                    (dotimes (i (- *outrag-event-max* 2))
                      (+! sum (- (-> *outrag-events* i sdc-time) (-> *outrag-sdc-times* i))))
                    sum
                    )
                  )
                (else (-> e sdc-time))
                ))
            (time-elapsed (if *outrag-section-started?* (- (real-current-time) *outrag-section-start-time*) 0))
            (time-remaining (- section-time time-elapsed))
            (timer-full-sec (/ time-remaining TICKS_PER_SECOND))
            (timer-min (/ timer-full-sec 60))
            (timer-sec (- timer-full-sec (* timer-min 60)))
            )
        ;; draw section info to bottom left
        (clear *next-section-str*)
        
        ;; SDC checks
        (when *mod-hard-mode?*
          ;; check if player has failed this section (SDC)
          (when (and (< time-remaining 0) ;; time is up
                    *outrag-section-started?* ;; section has started
                    (< (-> *game-info* money) (-> e orb-count)) ;; player has not met orb req (for case when headed back to geyser)
                    (not (process-by-name 'sdc-fail-proc *active-pool*))) ;; not already failing player
            ;; reset game loser
            (process-spawn-function process
              :name 'sdc-fail-proc
              ;This lambda is our function
              (lambda :behavior process ()
                ;; play fail sound
                (play-sound-file "outrag-fail.mp3" 
                  (the int (-> *setting-control* default dialog-volume)))
                (let ((t (real-current-time)))
                  (while (not (time-elapsed? t (seconds 5)))
                    ;; TODO - show fail text
                    (suspend)
                    )
                  )
                (reset-sc-stuff)
                (initialize! *game-info* 'game (the-as game-save #f) "game-start")
                (set-master-mode 'game)
                )
              )
            )

          (when (not *outrag-section-finished?*)
            (if (> time-remaining 0)
              (if (>= timer-sec 10) ;; too lazy to figure out zero padding for floats
                (format *next-section-str* "TIME REMAINING: ~D:~D~%" timer-min timer-sec)
                (format *next-section-str* "TIME REMAINING: ~D:0~D~%" timer-min timer-sec)
                )
              (format *next-section-str* "~3LTIME\c12S UP! YOU FAILED~0L~%")
              )
            (-! y 8)
            )
          )
        
        ;; show return to geyser reminder
        (when (and *outrag-section-finished?*
                  (>= *outrag-event-idx* 1)
                  (-> e geyser-play?))
          (format *next-section-str* "~3LReturn to Geyser Rock!~1L~%")
          (-! y 8)
          )
        (case *outrag-event-idx*
          ((0 1)
            (format *next-section-str* "Connection ~D Goal: ~D Orbs" 1 169))
          (else
            (format *next-section-str* "Connection ~D Goal: ~D Orbs" (- *outrag-event-idx* 1) (-> e orb-count)))
          )
        (draw-string-xy *next-section-str* buf 4 y (font-color white) (font-flags shadow kerning))
        )
      )
    )
  (none)
  )

(defun draw-unlock-info ()
  (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id subtitle))
    ;; play unlock sound effect if we just met the req from last frame
    (when (and (nonzero? *next-unlock-req*) (<= *next-unlock-req* (-> *game-info* money)))
      (play-sound-file "unlock.mp3" (the int (-> *setting-control* default sfx-volume)))
      )
    
    ;; find next unlockable (process w/ minimum orb-req > our current orbs)
    (set! *next-unlock-ptr* (the-as (pointer process) #f))
    (set! *next-unlock-req* 0.0)
    (iterate-process-tree *default-pool*
      (lambda ((this process)) 
        (let ((req (get-orb-req this)))
          (when (and (> req (-> *game-info* money))
                     (or (not *next-unlock-ptr*)
                         (< req *next-unlock-req*)))
              (set! *next-unlock-ptr* (process->ppointer this))
              (set! *next-unlock-req* req)
            )
          )
        #t)
      *null-kernel-context*)

    (cond 
      (*next-unlock-ptr*
        (let* ((p (ppointer->process *next-unlock-ptr*)))
          (format (clear *next-unlock-str*) "Next Unlock in ")
          ;; (format *next-unlock-str* (case (-> p type symbol)
          ;;     (('eco-green)   "~6LGreen Eco Cluster~1L~%")
          ;;     (('eco-blue)    "~7LBlue Eco Cluster~1L~%")
          ;;     (('eco-red)     "~3LRed Eco Cluster~1L~%")
          ;;     (('eco-yellow)  "~5LYellow Eco Cluster~1L~%")
          ;;     (('ventgreen)   "~6LGreen Eco Vent~1L~%")
          ;;     (('ventblue)    "~7LBlue Eco Vent~1L~%")
          ;;     (('ventred)     "~3LRed Eco Vent~1L~%")
          ;;     (('ventyellow)  "~5LYellow Eco Vent~1L~%")
          ;;     )
          ;;   )
          (format *next-unlock-str* "~D Orb~S (~D/~D)"
            (the int (- *next-unlock-req* (-> *game-info* money)))
            (if (> (- *next-unlock-req* (-> *game-info* money)) 1) "s" "") ;; optional s :)
            (the int (-> *game-info* money))
            (the int *next-unlock-req*)
            )
          )
        (draw-string-xy *next-unlock-str* buf 508 215 (font-color white) (font-flags right shadow kerning))
        )
      (else
        (format (clear *next-unlock-str*) "Next Unlock ~2LN/A")
        (draw-string-xy *next-unlock-str* buf 508 215 (font-color white) (font-flags right shadow kerning))
        )
      )   
    )
    (none)
  )

(defun runs-every-frame ()
  ;; play hints off (why do they keep turning on?)
  (false! (-> *setting-control* default play-hints))

  ;; close most tasks
  (dotimes (i (game-task max))
    (case i
      (((game-task none) (game-task complete) ;; dont care
        (game-task leaving-misty) ;; dont care
        (game-task assistant-village3) ;; unused
        ;; (game-task jungle-eggtop) ;; keep this open (blue eco switch)
        )
        ;; do nothing, don't close these tasks
        )
      (((game-task finalboss-movies))
        ;; close unless we're in superdupercharged mode
        (when (and (not *mod-hard-mode?*)
                   (not (task-closed? (the-as game-task i) (task-status need-reward-speech))))
          (close-specific-task! (the-as game-task i) (task-status need-reward-speech))
          )
        )
      (((game-task plunger-lurker-hit))
        (when (not (task-closed? (the-as game-task i) (task-status need-hint)))
          (close-specific-task! (the-as game-task i) (task-status need-hint))
          )
        )
      (((game-task village3-button))
        (when (not (task-closed? (the-as game-task i) (task-status need-introduction)))
          (close-specific-task! (the-as game-task i) (task-status need-introduction))
          )
        )
      (((game-task firecanyon-assistant) (game-task village2-levitator) (game-task lavatube-start) (game-task village4-button)) 
        (when (not (task-closed? (the-as game-task i) (task-status need-reward-speech)))
          (close-specific-task! (the-as game-task i) (task-status need-reward-speech))
          )
        )
      (else
        (when (not (task-closed? (the-as game-task i) (task-status need-resolution)))
          (logior! (-> *game-info* task-perm-list data i status) (entity-perm-status real-complete))
          (close-specific-task! (the-as game-task i) (task-status need-resolution))
          )
        )
      )
    )

  ;; kill some entities that don't respect their task status
  ;; beach
  (complete-entity-if-exists "ecoventrock-7")
  (complete-entity-if-exists "ecoventrock-4")
  (complete-entity-if-exists "ecoventrock-5")
  (complete-entity-if-exists "ecoventrock-3")
  (complete-entity-if-exists "ecoventrock-6")
  ;; jungle
  (complete-entity-if-exists "reflector-mirror-2")
  (complete-entity-if-exists "periscope-11")
  (complete-entity-if-exists "periscope-12")
  (complete-entity-if-exists "periscope-13")
  (complete-entity-if-exists "periscope-14")
  (complete-entity-if-exists "periscope-15")
  ;; jungleb
  (complete-entity-if-exists "plant-boss-3")
  ;; rolling
  (complete-entity-if-exists "lightning-mole-2")
  (complete-entity-if-exists "lightning-mole-3")
  (complete-entity-if-exists "lightning-mole-4")
  (complete-entity-if-exists "lightning-mole-5")
  (complete-entity-if-exists "robber-2")
  (complete-entity-if-exists "robber-3")
  (complete-entity-if-exists "robber-4")
  (complete-entity-if-exists "robber-5")
  ;; ogre
  (complete-entity-if-exists "ogreboss-1")
  ;; maincave
  (complete-entity-if-exists "gnawer-14")
  (complete-entity-if-exists "gnawer-19")
  (complete-entity-if-exists "gnawer-18")
  (complete-entity-if-exists "gnawer-17")
  (complete-entity-if-exists "gnawer-15")
  (complete-entity-if-exists "gnawer-13")
  (complete-entity-if-exists "gnawer-12")
  (complete-entity-if-exists "gnawer-16")
  (complete-entity-if-exists "gnawer-11")
  (complete-entity-if-exists "dark-crystal-1")
  (complete-entity-if-exists "dark-crystal-3")
  (complete-entity-if-exists "dark-crystal-4")
  (complete-entity-if-exists "dark-crystal-5")
  ;; darkcave
  (complete-entity-if-exists "dark-crystal-2")
  ;; snowy
  (complete-entity-if-exists "snow-bumper-72")
  (complete-entity-if-exists "snow-bumper-73")
  (complete-entity-if-exists "snow-bumper-81")
  (complete-entity-if-exists "snow-bumper-79")
  (complete-entity-if-exists "snow-bumper-78")
  (complete-entity-if-exists "snow-bumper-70")
  (complete-entity-if-exists "snow-bumper-71")
  (complete-entity-if-exists "snow-bumper-69")
  (complete-entity-if-exists "snow-bumper-80")
  (complete-entity-if-exists "snow-bumper-74")
  (complete-entity-if-exists "snow-bumper-75")
  (complete-entity-if-exists "snow-bumper-77")
  (complete-entity-if-exists "snow-bumper-76")
  (complete-entity-if-exists "ram-15")
  (complete-entity-if-exists "ram-8")
  (complete-entity-if-exists "ram-7")
  (complete-entity-if-exists "ram-14")
  (complete-entity-if-exists "ram-13")
  ;; citadel
  (complete-entity-if-exists "citb-generator-1")
  (complete-entity-if-exists "citb-generator-2")
  (complete-entity-if-exists "citb-generator-3")
  (complete-entity-if-exists "citb-generator-4")
  (let ((bc (entity-by-name "citb-battlecontroller-1")))
    (when bc (set! (-> bc extra perm user-int8 0) 1)))
  (complete-entity-if-exists "citb-generator-5")
  (complete-entity-if-exists "citb-generator-6")
  (complete-entity-if-exists "citb-generator-7")
  ;; finalboss
  (when (not *mod-hard-mode?*)
    (kill-entity-if-exists "robotboss-3"))

  ;; draw the info about section, next unlockable
  (case (-> *target* state name) :comp name=
    (('target-title 'target-title-play 'target-title-wait 'target-continue) ;; nothing
      )
    (else
      (when (not (paused?))
        (draw-section-info)
        (draw-unlock-info)
        )
      )
    )

  (if *show-input-display* (input-display-on) (input-display-off))
  ;; ensure orb-placer is spawned/killed as requested, debug menu is updated
  (when *debug-segment*
    (orb-placer-maintenance))
  (none))

(defun runs-on-orb-pickup ((parent process-tree))
  (let* ((from-cache? (and parent (type-type? (-> parent type) orb-cache-top))))
    ;; Code here runs on ANY orb pickup
    (when from-cache?
      ;; Code here runs only if the orb was from an orb cache
      )
    (when (not from-cache?)
      ;; Code here runs only if the orb was NOT from an orb cache
      ))
  (none))

(defun runs-on-fly-pickup ()
  ;; Code here runs on any scout fly pickup
  (none))

(defun runs-on-cell-pickup ((cell-event symbol))
  (case cell-event
    (('pickup)
     ;; Code here runs as soon as you pickup a powercell
     )
    (('cutscene-end)
     ;; Code here runs at the end of any powercell cutscene
     ))
  (none))

(defun runs-on-eco-pickup ((eco-type pickup-type) (parent process-tree))
  (let* ((from-vent? (and parent (type-type? (-> parent type) vent))))
    ;; Code here runs as soon as you pickup ANY eco
    (case eco-type
      (((pickup-type eco-yellow))
       ;; Code here runs as soon as you pickup yellow eco
       )
      (((pickup-type eco-red))
       ;; Code here runs as soon as you pickup red eco
       )
      (((pickup-type eco-blue))
       ;; Code here runs as soon as you pickup blue eco
       )
      (((pickup-type eco-pill))
       ;; Code here runs as soon as you pickup small green eco
       )
      (((pickup-type eco-green))
       ;; Code here runs as soon as you pickup big green eco 
       ))
    (when from-vent?
      ;; Code here runs only if the eco was picked up from a vent
      ))
  (none))

(defun runs-on-jak-spawn ()
  ;; Code here runs every time jak spawns (loading a file new game or death)
  ;;uncomment this to use custom music for custom levels - the function is in mod-common-functions.gc
  ;;(process-spawn-function process music-manager-proc)
  
  ;; fix some pause shit
  (remove-setting *setting-control* *target* 'allow-pause)
  (remove-setting *setting-control* *target* 'allow-progress)
  (apply-settings *setting-control*)
  
  ;; full HP and blue eco
  (send-event *target* 'get-pickup (pickup-type eco-blue) (-> *FACT-bank* eco-full-inc)) ;; mod change - full blue eco on spawn
  (set! (-> *target* fact health) 3.0)
  (set! (-> *target* fact eco-pill) 50.0) ;; 4HP

  ;; make sure we have an autosave, defaulting to slot 0
  (when (and (not *debug-segment*) (< (-> *game-info* auto-save-which) 0))
    (format 0 "TARGET SPAWN - NO AUTOSAVE DETECTED, CREATING ONE FOR SLOT 0 NOW~%")
    ;; make sure its enabled
    (set! (-> *setting-control* current auto-save) #t)
    (set! (-> *setting-control* default auto-save) #t)
    (auto-save-command 'save 0 0 *default-pool*)
    )

  (none))

(defun runs-on-jak-death ((death-event symbol))
  (case death-event
    (('dying)
     ;; Code here runs immediately every time jak dies, before any death animation or death cutscene
     )
    (('blackout)
     ;; Code here runs after jak dies (and any death cutscene finishes), during the blackout before he spawns
     ))
  (none))

;;;;;;;;;;;;;;;;;;;;;;;;;;
;; deprecated function defintions.
;;;;;;;;;;;;;;;;;;;;;;;;;;

#| these are no longer recommended/supported however we include them anyways to not break anyones mods. |#
