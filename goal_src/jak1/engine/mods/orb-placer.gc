(in-package goal)
(declare-file (debug))

;; controls whether the orb-placer process will run
(define *orb-placer-enabled?* #f)
;; controls whether placer is actually active vs paused
(define *entity-placer-edit-mode?* #f)

;; number of orbs orb-placer has placed
(define *orb-placer-count* 0)

;; max number of orbs
(defconstant ORB_PLACER_MAX 100)

;; index of currently selected orb for placing
(define *orb-placer-selected-idx* -1)

;; array of handles to orbs that have been spawned by orb-placer
(define *orb-placer-orbs* (new 'global 'boxed-array handle ORB_PLACER_MAX))

(define *orb-placer-temp-strs*
  (new 'static
       'boxed-array
       :type
       string
       :length
       ORB_PLACER_MAX
       "ventblue-00"
       "ventblue-01"
       "ventblue-02"
       "ventblue-03"
       "ventblue-04"
       "ventblue-05"
       "ventblue-06"
       "ventblue-07"
       "ventblue-08"
       "ventblue-09"
       "ventblue-10"
       "ventblue-11"
       "ventblue-12"
       "ventblue-13"
       "ventblue-14"
       "ventblue-15"
       "ventblue-16"
       "ventblue-17"
       "ventblue-18"
       "ventblue-19"
       "ventblue-20"
       "ventblue-21"
       "ventblue-22"
       "ventblue-23"
       "ventblue-24"
       "ventblue-25"
       "ventblue-26"
       "ventblue-27"
       "ventblue-28"
       "ventblue-29"
       "ventblue-30"
       "ventblue-31"
       "ventblue-32"
       "ventblue-33"
       "ventblue-34"
       "ventblue-35"
       "ventblue-36"
       "ventblue-37"
       "ventblue-38"
       "ventblue-39"
       "ventblue-40"
       "ventblue-41"
       "ventblue-42"
       "ventblue-43"
       "ventblue-44"
       "ventblue-45"
       "ventblue-46"
       "ventblue-47"
       "ventblue-48"
       "ventblue-49"
       "ventblue-50"
       "ventblue-51"
       "ventblue-52"
       "ventblue-53"
       "ventblue-54"
       "ventblue-55"
       "ventblue-56"
       "ventblue-57"
       "ventblue-58"
       "ventblue-59"
       "ventblue-60"
       "ventblue-61"
       "ventblue-62"
       "ventblue-63"
       "ventblue-64"
       "ventblue-65"
       "ventblue-66"
       "ventblue-67"
       "ventblue-68"
       "ventblue-69"
       "ventblue-70"
       "ventblue-71"
       "ventblue-72"
       "ventblue-73"
       "ventblue-74"
       "ventblue-75"
       "ventblue-76"
       "ventblue-77"
       "ventblue-78"
       "ventblue-79"
       "ventblue-80"
       "ventblue-81"
       "ventblue-82"
       "ventblue-83"
       "ventblue-84"
       "ventblue-85"
       "ventblue-86"
       "ventblue-87"
       "ventblue-88"
       "ventblue-89"
       "ventblue-90"
       "ventblue-91"
       "ventblue-92"
       "ventblue-93"
       "ventblue-94"
       "ventblue-95"
       "ventblue-96"
       "ventblue-97"
       "ventblue-98"
       "ventblue-99"))

;; global for this so we can repopulate it as needed
(define *orb-placer-select-menu* (the-as debug-menu #f))

(defun dm-orb-placer-select-func ((idx int) (msg debug-menu-msg))
  (when (= msg (debug-menu-msg press))
    (cond
      ((= *orb-placer-selected-idx* idx)
       ;; deselect
       (set! *orb-placer-selected-idx* -1)
       (set! *orb-placer-enabled?* #f)
       (false! *entity-placer-edit-mode?*))
      (else
       ;; select
       (set! *orb-placer-selected-idx* idx)
       (set! *orb-placer-enabled?* #t)
       (true! *entity-placer-edit-mode?*))))
  (= *orb-placer-selected-idx* idx))

(defun orb-placer-highlight ((orb process-drawable) (highlight? symbol))
  (return 0)
  (cond
    (highlight?
     (set-vector! (-> orb draw color-mult) 0.8 0.8 0.0 1.0)
     (set-vector! (-> orb draw color-emissive) 0.0 1.0 0.2 1.0))
    (else (set-vector! (-> orb draw color-mult) 0.8 0.8 0.8 1.0) (set-vector! (-> orb draw color-emissive) 0.2 0.2 0.2 1.0)))
  (none))

(defun orb-placer-list-maintenance ((update-debug-list? symbol))
  (when update-debug-list?
    (debug-menu-remove-all-items *orb-placer-select-menu*))
  (dotimes (i *orb-placer-count*)
    (let ((orb-handle (-> *orb-placer-orbs* i))
          (is-selected? (and *orb-placer-enabled?* (= i *orb-placer-selected-idx*))))
      (when (and (nonzero? orb-handle) (handle->process orb-handle))
        (let ((orb-proc (the process-drawable (handle->process orb-handle))))
          (when (and orb-proc (!= (-> orb-proc next-state name) 'dead-state) (!= (-> orb-proc next-state name) 'hud-collecting))
            ;; ensure correct highlighting
            (orb-placer-highlight orb-proc is-selected?)
            ;; draw z-debug text
            (add-debug-text-3d #t
                               (bucket-id debug-no-zbuf)
                               (-> *orb-placer-temp-strs* i)
                               (-> orb-proc root trans) ;; (-> orb-proc base)
                               (if is-selected? 
                                (if *entity-placer-edit-mode?* (font-color green) (font-color red))
                                (font-color white))
                               (new 'static 'vector2h :y 16))
            (when update-debug-list?
              ;; append to debug menu list
              (let ((orb-menu-item (new-dm-flag (-> *orb-placer-temp-strs* i) i dm-orb-placer-select-func)))
                (debug-menu-append-item *orb-placer-select-menu* orb-menu-item)
                (when is-selected?
                  (set! (-> *orb-placer-select-menu* selected-item) orb-menu-item)))))))))
  (when update-debug-list?
    (set! (-> *orb-placer-select-menu* items) (sort (-> *orb-placer-select-menu* items) debug-menu-node<?)))
  (none))

(defun orb-placer-add ()
  (when (< *orb-placer-count* ORB_PLACER_MAX)
    (let ((vec (new 'stack-no-clear 'vector))
          (camera-quat (new-stack-quaternion0))
          (camera-z-vector (new-stack-vector0)))
      ;; figure out spawn position
      (cond
        (*target*
         ;; jak exists, use his position
         (vector-copy! vec (-> *target* root trans))
         (+! (-> vec y) (meters 2.0)) ;; dont spawn in ground
         )
        (else
         ;; use camera position
         (vector-copy! vec (-> *math-camera* trans))))
      ;; convert the camera angle from a matrix to a quaternion (???)
      (matrix->quaternion camera-quat (-> *camera-combiner* inv-camera-rot))
      ;; convert the quaternion to a vector representing rotation around z axis (isnt it the y axis in GOAL tho?)
      (vector-z-quaternion! camera-z-vector camera-quat)
      ;; shift orb's position with camera angle, by 3m
      (vector+! vec vec (vector-normalize! camera-z-vector (meters 3.0)))
      ;; spawn and update orb-placer data
      (let ((orb-handle (spawn-ventblue vec 0.0)))
        (when (nonzero? orb-handle)
          (set! (-> *orb-placer-orbs* *orb-placer-count*) orb-handle)
          (set! *orb-placer-selected-idx* *orb-placer-count*)
          (true! *orb-placer-enabled?*)
          (true! *entity-placer-edit-mode?*)
          (orb-placer-highlight (the ventblue (handle->process orb-handle)) #t)
          (+! *orb-placer-count* 1)
          (orb-placer-list-maintenance #t)))))
  (none))

(defun orb-placer-print-selected ()
  (when (and (>= *orb-placer-selected-idx* 0) (nonzero? (-> *orb-placer-orbs* *orb-placer-selected-idx*)))
    (let ((orb (the process-drawable (handle->process (-> *orb-placer-orbs* *orb-placer-selected-idx*)))))
      (when orb
        (format 0 " ~m, ~m, ~m~%" (-> orb root trans x) (-> orb root trans y) (-> orb root trans z)))))
  (none))

(defun orb-placer-print-all ()
  (format 0 "|------------ventblue start------------|~%")
  (dotimes (i *orb-placer-count*)
    (let ((orb-handle (-> *orb-placer-orbs* i)))
      (when (and (nonzero? orb-handle) (handle->process orb-handle))
        (let ((orb (the process-drawable (handle->process orb-handle))))
          (format 0 " ~m, ~m, ~m~%" (-> orb root trans x) (-> orb root trans y) (-> orb root trans z))))))
  (format 0 "|-------------ventblue end-------------|~%")
  (none))

;; called from run-every-frame to ensure orb-placer is spawned/killed
(define *orb-offset-tmp-vec* (new 'global 'vector))
(define *orb-placer-hud-str* (new 'global 'string 128 (the string #f)))
(define *square-hold-time* (the time-frame #f))
(define *circle-hold-time* (the time-frame #f))
(defun orb-placer-maintenance ()
  (when *debug-segment*
    (orb-placer-list-maintenance #f)
    (when (and (not (paused?)) *orb-placer-enabled?*)
      ;; handle edit mode toggle
      (when (cpad-pressed? 0 triangle)
        (not! *entity-placer-edit-mode?*))

      (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id subtitle))
        (format (clear *orb-placer-hud-str*) "Vent Placer Edit Mode ")
        (cond
          (*entity-placer-edit-mode?* (format *orb-placer-hud-str* "~6LACTIVE~%"))
          (else (format *orb-placer-hud-str* "~2LPAUSED~%"))
          )
        (when (> *orb-placer-selected-idx* -1)
          (let ((orb (the ventblue (handle->process (-> *orb-placer-orbs* *orb-placer-selected-idx*)))))
            (when orb
              (format *orb-placer-hud-str* "Orb Requirement: ~D" (the int (-> orb orb-req)))
              )
            )
          )
        (draw-string-xy *orb-placer-hud-str* buf 508 2 (font-color red) (font-flags right shadow kerning))
        )
      )
    (cond
      ((process-by-name "orb-placer" *active-pool*)
       ;; orb-placer exists
       ;; if its not enabled, kill it
       (when (not (and *debug-segment* *orb-placer-enabled?*))
         (kill-by-name "orb-placer" *active-pool*)
         ;; make sure target is ungrabbed
         (when (and *target* (= (-> *target* next-state name) 'target-grab))
           (send-event *target* 'end-mode))
         ;; release freecam if no target
         (when (and (not *target*) (not (send-event *camera* 'query-state cam-free-floating)))
           (send-event *camera* 'change-state cam-free-floating 0))))
      (else
       ;; orb-placer doesn't exist
       ;; if its enabled, spawn it
       (when (and *debug-segment* *orb-placer-enabled?*)
         ;; process-spawn-function, spawns a process that runs the function you give it
         (process-spawn-function process
           :name "orb-placer"
           (lambda :behavior process ()
             (stack-size-set! (-> self top-thread) 512)
             ;; Code before the loop runs once on process spawn
             (let ((pad (-> *cpad-list* cpads 0))
                   (vec *orb-offset-tmp-vec*))
               (loop
                 ;; Loop runs once per frame while process is active
                 (cond
                    ((not *entity-placer-edit-mode?*) ;; disabled
                      ;; make sure target is released
                      (when (and *target* (= (-> *target* next-state name) 'target-grab))
                        (send-event *target* 'end-mode))
                      ;; unlock freecam if no target
                      (when (and (not *target*) (not (send-event *camera* 'query-state cam-free-floating)))
                        (send-event *camera* 'change-state cam-free-floating 0))
                      ;; clear these
                      (set! *square-hold-time* (the time-frame #f)) ;; make sure square not considered held
                      (set! *circle-hold-time* (the time-frame #f)) ;; make sure circle not considered held
                      )
                    (else ;; active
                      ;; make sure target is grabbed
                      (when (and *target* (!= (-> *target* next-state name) 'target-grab))
                        (send-event *target* 'change-mode 'grab))
                      ;; lock freecam if no target
                      (when (and (not *target*) (not (send-event *camera* 'query-state cam-fixed)))
                        (send-event *camera* 'change-state cam-fixed 0))
                      ;; if we have an orb selected and the handle is nonzero...
                      (cond
                        ((and (>= *orb-placer-selected-idx* 0) (nonzero? (-> *orb-placer-orbs* *orb-placer-selected-idx*)) (handle->process (-> *orb-placer-orbs* *orb-placer-selected-idx*)))
                          (let ((orb (the ventblue (handle->process (-> *orb-placer-orbs* *orb-placer-selected-idx*))))
                                (moved? #f))
                            (when orb
                              ;; highlight it
                              (orb-placer-highlight orb #t)
                              ;; respond to controller input
                              ;; X/Z based on camera
                              (when (nonzero? (-> pad stick0-speed))
                                (set! (-> vec x) (sin (-> pad stick0-dir)))
                                (set! (-> vec y) 0.0)
                                (set! (-> vec z) (cos (-> pad stick0-dir)))
                                (set! (-> vec w) 0.0)
                                ;; camera magic
                                (vector-matrix*! vec vec (matrix-local->world #t #f))
                                (vector-flatten! vec vec (-> *camera* local-down))
                                (vector-float*! vec vec (* (-> pad stick0-speed) 512.0)) ;; TODO scale?
                                ;; actually move orb
                                (vector+! (-> orb root trans) (-> orb root trans) vec)
                                ;;  (vector+! (-> orb base) (-> orb base) vec))
                                (true! moved?)
                                )
                              (cond
                                ((cpad-pressed? 0 square)
                                (-! (-> orb orb-req) 1.0)
                                (set! *square-hold-time* (the time-frame #f)) ;; make sure square not considered held
                                (set! *circle-hold-time* (the time-frame #f)) ;; make sure circle not considered held
                                )
                                ((cpad-pressed? 0 circle)
                                (+! (-> orb orb-req) 1.0)
                                (set! *square-hold-time* (the time-frame #f)) ;; make sure square not considered held
                                (set! *circle-hold-time* (the time-frame #f)) ;; make sure circle not considered held
                                )
                                ((cpad-hold? 0 square)
                                (set! *circle-hold-time* (the time-frame #f)) ;; square held, make sure circle not considered held
                                (when (not *square-hold-time*) (set-time! *square-hold-time*)) ;; if we werent already holding square, set the hold time
                                (when (zero? (mod (current-time) 50))
                                  (-! (-> orb orb-req) (the int (* (the float (* (- (current-time) *square-hold-time*) (- (current-time) *square-hold-time*))) 0.0002))) ;; subtract O(square-hold-time^2) ?
                                  ))
                                ((cpad-hold? 0 circle)
                                (set! *square-hold-time* (the time-frame #f)) ;; circle held, make sure square not considered held
                                (when (not *circle-hold-time*) (set-time! *circle-hold-time*)) ;; if we werent already holding circle, set the hold time
                                (when (zero? (mod (current-time) 50))
                                  (+! (-> orb orb-req) (the int (* (the float (* (- (current-time) *circle-hold-time*) (- (current-time) *circle-hold-time*))) 0.0002))) ;; add O(circle-hold-time^2) ?
                                  ))
                                (else
                                (set! *square-hold-time* (the time-frame #f)) ;; make sure square not considered held
                                (set! *circle-hold-time* (the time-frame #f)) ;; make sure circle not considered held                              
                                )
                                )
                              (when (< (-> orb orb-req) 0.0)
                                (set! (-> orb orb-req) 0.0)) ;; clamp to 0
                              (when (> (-> orb orb-req) 2000.0)
                                (set! (-> orb orb-req) 2000.0)) ;; clamp to 2000
                              (cond
                                ;; fine tune/axis-aligned X/Z
                                ((cpad-pressed? 0 down) (true! moved?) (+! (-> orb root trans z) (meters 0.03))) ;; (+! (-> orb base z) (meters 0.03)))
                                ((cpad-pressed? 0 up) (true! moved?) (+! (-> orb root trans z) (meters -0.03))) ;; (+! (-> orb base z) (meters -0.03)))
                                ((cpad-pressed? 0 right) (true! moved?) (+! (-> orb root trans x) (meters 0.03))) ;; (+! (-> orb base x) (meters 0.03)))
                                ((cpad-pressed? 0 left) (true! moved?) (+! (-> orb root trans x) (meters -0.03))) ;; (+! (-> orb base x) (meters -0.03)))
                                ;; Y (up/down)
                                ((cpad-hold? 0 r2) (true! moved?) (+! (-> orb root trans y) (meters 0.08))) ;; (+! (-> orb base y) (meters 0.08)))
                                ((cpad-hold? 0 l2) (true! moved?) (+! (-> orb root trans y) (meters -0.08))) ;; (+! (-> orb base y) (meters -0.08)))
                                ((cpad-pressed? 0 r1) (true! moved?) (+! (-> orb root trans y) (meters 0.03))) ;; (+! (-> orb base y) (meters 0.03)))
                                ((cpad-pressed? 0 l1) (true! moved?) (+! (-> orb root trans y) (meters -0.03))) ;; (+! (-> orb base y) (meters -0.03)))
                                )

                              (when moved?
                                ;; un sleep 
                                (logclear! (-> orb mask) (process-mask sleep))
                                ;; force update transforms
                                (when (type-type? (-> orb root type) collide-shape)
                                  (update-transforms! (the collide-shape (-> orb root)))))
                              )
                            )
                          )
                        (else
                          ;; clear these
                          (set! *square-hold-time* (the time-frame #f)) ;; make sure square not considered held
                          (set! *circle-hold-time* (the time-frame #f)) ;; make sure circle not considered held
                          )
                        )
                      )
                    )
                  
                  ;; Processes should suspend themselves, the loop will resume next frame
                  (suspend)))))))))
  (none))


(defun orb-placer-clear! ()
  (dotimes (idx *orb-placer-count*)
    (cond
      ((and (-> *orb-placer-orbs* idx) (nonzero? (-> *orb-placer-orbs* idx)) (handle->process (-> *orb-placer-orbs* idx)))
        (deactivate (handle->process (-> *orb-placer-orbs* idx)))
        (set! (-> *orb-placer-orbs* idx) (the-as handle #f))
        )
      )
    )
  (set! *orb-placer-count* 0)
  (set! *orb-placer-selected-idx* -1)
  (set! *entity-placer-edit-mode?* #f)
  (none)
  0
  )

;; file save/load stuff

(defun orbs-handle-input-settings ((file file-stream))
  ;; Parses an orb line in the file, expecting the format: (orb-idx x y z bob-scale type)
  (let* ((orb-idx (string->int *pc-temp-string*))
         (x (file-stream-read-float file))
         (y (file-stream-read-float file))
         (z (file-stream-read-float file))
         (v (new-stack-vector0))
         (orb-req (file-stream-read-float file))
         )
    (set! *orb-placer-count* (max *orb-placer-count* (+ orb-idx 1)))
    ;; (dbg-format 0 "load spawn-ventblue from file, total count is now ~D~%" *orb-placer-count*)
    (set-vector-meters! v x y z)
    (let ((orb-handle (spawn-ventblue v orb-req))) ;; just pass type/amount=1.0 here and we set the type after its spawned
      (when (nonzero? orb-handle)
        ;; (orb-placer-set-marking (the skill (handle->process orb-handle)) type)
        (set! (-> *orb-placer-orbs* orb-idx) orb-handle)
        )
      )
    )
  0)

(defun orbs-read-from-file ((filename string))
  (if (not filename)
    (return #f))

  (let ((file (new 'stack 'file-stream filename 'read)))
    (when (not (file-stream-valid? file))
      (return #f))

    (with-settings-scope (file)
      (case-str (file-stream-read-word file)
        (("settings")
          (file-stream-read-int file) ;; burn thru version field
          (dosettings (file)
            (orbs-handle-input-settings file)
            )
          )
        )
      )
    (orb-placer-list-maintenance #t)

    (file-stream-close file)
    )

  ;; (dbg-format 0 "vent-placer file read: ~A~%" filename)

  #t
  )

(defun orbs-handle-output-settings ((file file-stream))
  (dotimes (idx *orb-placer-count*)
    (cond
      ((and (-> *orb-placer-orbs* idx) (nonzero? (-> *orb-placer-orbs* idx)) (handle->process (-> *orb-placer-orbs* idx)))
        (let* ((orb (the ventblue (handle->process (-> *orb-placer-orbs* idx))))
               (v (-> orb root trans)) ;; (-> orb base))
               (orb-req (-> orb orb-req))
               )
          (format file "  (~D ~m ~m ~m ~F)~%" idx (-> v x) (-> v y) (-> v z) orb-req)
          )
        )
      (else
        ;; skipped orb?
        (format 0 "found missing vent in idx ~D, skipping~%" idx)
        )
      )
    )

  0)

(defun orbs-write-to-file ((filename string))
  (if (not filename)
    (return #f))

  (let ((file (new 'stack 'file-stream filename 'write)))
    (if (not (file-stream-valid? file))
      (return #f))

    (format file "(settings #x~X~%" PC_KERNEL_VERSION)

    (orbs-handle-output-settings file)

    (format file "  )~%")
    (file-stream-close file)
    )

  (format 0 "vent-placer file write: ~A~%" filename)

  #t
  )

(define *orba-filename* "VENTBLUE-")

(defun orbs-save-to-file ((filenum int))
  (format (clear *pc-temp-string-1*) "~S/~S~D.gc" *pc-settings-folder* *orba-filename* filenum)
  (pc-mkdir-file-path *pc-temp-string-1*)
  (orbs-write-to-file *pc-temp-string-1*)
  (none))
;; too lazy to do this better
(defun orbs-save-to-file-1 () (orbs-save-to-file 1))
(defun orbs-save-to-file-2 () (orbs-save-to-file 2))
(defun orbs-save-to-file-3 () (orbs-save-to-file 3))
(defun orbs-save-to-file-4 () (orbs-save-to-file 4))

(defun orbs-load ((filenum int))
  (format (clear *pc-temp-string-1*) "~S/~S~D.gc" *pc-settings-folder* *orba-filename* filenum)
  (cond
    ((pc-filepath-exists? *pc-temp-string-1*)
      (format 0 "[PC] Vent Placer Settings found at '~S'...loading!~%" *pc-temp-string-1*)
      (orb-placer-clear!)
      (unless (orbs-read-from-file *pc-temp-string-1*)
        (format 0 "[PC] Vent Placer Settings found at '~S' but could not be loaded!~%" *pc-temp-string-1*)
        )
      )
    (else
      (format 0 "[PC] Vent Placer Settings not found at '~S'~%" *pc-temp-string-1*)
      )
    )
  0)
;; too lazy to do this better
(defun orbs-load-1 () (orbs-load 1))
(defun orbs-load-2 () (orbs-load 2))
(defun orbs-load-3 () (orbs-load 3))
(defun orbs-load-4 () (orbs-load 4))